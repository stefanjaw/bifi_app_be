/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from "mongoose";

/**
 * Lean version of CompanyDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CompanyDocument.toObject()`. To avoid conflicts with model names, use the type alias `CompanyObject`.
 * ```
 * const companyObject = company.toObject();
 * ```
 */
export type Company = {
  name: string;
  countryId: Country;
  address: string;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of CompanyDocument (type alias of `Company`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Company } from "../models"
 * import { CompanyObject } from "../interfaces/mongoose.gen.ts"
 *
 * const companyObject: CompanyObject = company.toObject();
 * ```
 */
export type CompanyObject = Company;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CompanyQuery = mongoose.Query<
  any,
  CompanyDocument,
  CompanyQueries
> &
  CompanyQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `CompanySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CompanyQueries = {
  paginate: (this: CompanyQuery, ...args: any[]) => CompanyQuery;
};

export type CompanyMethods = {};

export type CompanyStatics = {
  paginate: (this: CompanyModel, ...args: any[]) => any;
  paginateSubDocs: (this: CompanyModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Company = mongoose.model<CompanyDocument, CompanyModel>("Company", CompanySchema);
 * ```
 */
export type CompanyModel = mongoose.Model<CompanyDocument, CompanyQueries> &
  CompanyStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Company schema instances:
 * ```
 * const CompanySchema: CompanySchema = new mongoose.Schema({ ... })
 * ```
 */
export type CompanySchema = mongoose.Schema<
  CompanyDocument,
  CompanyModel,
  CompanyMethods,
  CompanyQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Company = mongoose.model<CompanyDocument, CompanyModel>("Company", CompanySchema);
 * ```
 */
export type CompanyDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CompanyQueries
> &
  CompanyMethods & {
    name: string;
    countryId: CountryDocument;
    address: string;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ContactDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ContactDocument.toObject()`. To avoid conflicts with model names, use the type alias `ContactObject`.
 * ```
 * const contactObject = contact.toObject();
 * ```
 */
export type Contact = {
  name: string;
  lastName: string;
  phoneNumber?: string;
  email: string;
  parentId?: Contact;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ContactDocument (type alias of `Contact`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Contact } from "../models"
 * import { ContactObject } from "../interfaces/mongoose.gen.ts"
 *
 * const contactObject: ContactObject = contact.toObject();
 * ```
 */
export type ContactObject = Contact;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ContactQuery = mongoose.Query<
  any,
  ContactDocument,
  ContactQueries
> &
  ContactQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ContactSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ContactQueries = {
  paginate: (this: ContactQuery, ...args: any[]) => ContactQuery;
};

export type ContactMethods = {};

export type ContactStatics = {
  paginate: (this: ContactModel, ...args: any[]) => any;
  paginateSubDocs: (this: ContactModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Contact = mongoose.model<ContactDocument, ContactModel>("Contact", ContactSchema);
 * ```
 */
export type ContactModel = mongoose.Model<ContactDocument, ContactQueries> &
  ContactStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Contact schema instances:
 * ```
 * const ContactSchema: ContactSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ContactSchema = mongoose.Schema<
  ContactDocument,
  ContactModel,
  ContactMethods,
  ContactQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Contact = mongoose.model<ContactDocument, ContactModel>("Contact", ContactSchema);
 * ```
 */
export type ContactDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ContactQueries
> &
  ContactMethods & {
    name: string;
    lastName: string;
    phoneNumber?: string;
    email: string;
    parentId?: ContactDocument;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of CountryDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CountryDocument.toObject()`. To avoid conflicts with model names, use the type alias `CountryObject`.
 * ```
 * const countryObject = country.toObject();
 * ```
 */
export type Country = {
  name: string;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of CountryDocument (type alias of `Country`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Country } from "../models"
 * import { CountryObject } from "../interfaces/mongoose.gen.ts"
 *
 * const countryObject: CountryObject = country.toObject();
 * ```
 */
export type CountryObject = Country;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CountryQuery = mongoose.Query<
  any,
  CountryDocument,
  CountryQueries
> &
  CountryQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `CountrySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CountryQueries = {
  paginate: (this: CountryQuery, ...args: any[]) => CountryQuery;
};

export type CountryMethods = {};

export type CountryStatics = {
  paginate: (this: CountryModel, ...args: any[]) => any;
  paginateSubDocs: (this: CountryModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Country = mongoose.model<CountryDocument, CountryModel>("Country", CountrySchema);
 * ```
 */
export type CountryModel = mongoose.Model<CountryDocument, CountryQueries> &
  CountryStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Country schema instances:
 * ```
 * const CountrySchema: CountrySchema = new mongoose.Schema({ ... })
 * ```
 */
export type CountrySchema = mongoose.Schema<
  CountryDocument,
  CountryModel,
  CountryMethods,
  CountryQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Country = mongoose.model<CountryDocument, CountryModel>("Country", CountrySchema);
 * ```
 */
export type CountryDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CountryQueries
> &
  CountryMethods & {
    name: string;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of FacilityDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FacilityDocument.toObject()`. To avoid conflicts with model names, use the type alias `FacilityObject`.
 * ```
 * const facilityObject = facility.toObject();
 * ```
 */
export type Facility = {
  name: string;
  mainPlace: Contact;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
  rooms: any;
};

/**
 * Lean version of FacilityDocument (type alias of `Facility`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Facility } from "../models"
 * import { FacilityObject } from "../interfaces/mongoose.gen.ts"
 *
 * const facilityObject: FacilityObject = facility.toObject();
 * ```
 */
export type FacilityObject = Facility;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FacilityQuery = mongoose.Query<
  any,
  FacilityDocument,
  FacilityQueries
> &
  FacilityQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `FacilitySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FacilityQueries = {
  paginate: (this: FacilityQuery, ...args: any[]) => FacilityQuery;
};

export type FacilityMethods = {};

export type FacilityStatics = {
  paginate: (this: FacilityModel, ...args: any[]) => any;
  paginateSubDocs: (this: FacilityModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Facility = mongoose.model<FacilityDocument, FacilityModel>("Facility", FacilitySchema);
 * ```
 */
export type FacilityModel = mongoose.Model<FacilityDocument, FacilityQueries> &
  FacilityStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Facility schema instances:
 * ```
 * const FacilitySchema: FacilitySchema = new mongoose.Schema({ ... })
 * ```
 */
export type FacilitySchema = mongoose.Schema<
  FacilityDocument,
  FacilityModel,
  FacilityMethods,
  FacilityQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Facility = mongoose.model<FacilityDocument, FacilityModel>("Facility", FacilitySchema);
 * ```
 */
export type FacilityDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FacilityQueries
> &
  FacilityMethods & {
    name: string;
    mainPlace: ContactDocument;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
    rooms: any;
  };

/**
 * Lean version of RoomDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RoomDocument.toObject()`. To avoid conflicts with model names, use the type alias `RoomObject`.
 * ```
 * const roomObject = room.toObject();
 * ```
 */
export type Room = {
  name: string;
  code: string;
  address: string;
  facilityId: Facility;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of RoomDocument (type alias of `Room`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Room } from "../models"
 * import { RoomObject } from "../interfaces/mongoose.gen.ts"
 *
 * const roomObject: RoomObject = room.toObject();
 * ```
 */
export type RoomObject = Room;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RoomQuery = mongoose.Query<any, RoomDocument, RoomQueries> &
  RoomQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `RoomSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RoomQueries = {
  paginate: (this: RoomQuery, ...args: any[]) => RoomQuery;
};

export type RoomMethods = {};

export type RoomStatics = {
  paginate: (this: RoomModel, ...args: any[]) => any;
  paginateSubDocs: (this: RoomModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Room = mongoose.model<RoomDocument, RoomModel>("Room", RoomSchema);
 * ```
 */
export type RoomModel = mongoose.Model<RoomDocument, RoomQueries> & RoomStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Room schema instances:
 * ```
 * const RoomSchema: RoomSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RoomSchema = mongoose.Schema<
  RoomDocument,
  RoomModel,
  RoomMethods,
  RoomQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Room = mongoose.model<RoomDocument, RoomModel>("Room", RoomSchema);
 * ```
 */
export type RoomDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RoomQueries
> &
  RoomMethods & {
    name: string;
    code: string;
    address: string;
    facilityId: FacilityDocument;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of MaintenanceWindowDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MaintenanceWindowDocument.toObject()`. To avoid conflicts with model names, use the type alias `MaintenanceWindowObject`.
 * ```
 * const maintenancewindowObject = maintenancewindow.toObject();
 * ```
 */
export type MaintenanceWindow = {
  name: string;
  daysBefore: number;
  daysAfter: number;
  recurrency:
    | "daily"
    | "weekly"
    | "monthly"
    | "quarterly"
    | "semi-anually"
    | "annually";
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of MaintenanceWindowDocument (type alias of `MaintenanceWindow`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { MaintenanceWindow } from "../models"
 * import { MaintenanceWindowObject } from "../interfaces/mongoose.gen.ts"
 *
 * const maintenancewindowObject: MaintenanceWindowObject = maintenancewindow.toObject();
 * ```
 */
export type MaintenanceWindowObject = MaintenanceWindow;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MaintenanceWindowQuery = mongoose.Query<
  any,
  MaintenanceWindowDocument,
  MaintenanceWindowQueries
> &
  MaintenanceWindowQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `MaintenanceWindowSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MaintenanceWindowQueries = {
  paginate: (
    this: MaintenanceWindowQuery,
    ...args: any[]
  ) => MaintenanceWindowQuery;
};

export type MaintenanceWindowMethods = {
  parseRecurrencyForDayjs: (
    this: MaintenanceWindowDocument,
    ...args: any[]
  ) => any;
};

export type MaintenanceWindowStatics = {
  paginate: (this: MaintenanceWindowModel, ...args: any[]) => any;
  paginateSubDocs: (this: MaintenanceWindowModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MaintenanceWindow = mongoose.model<MaintenanceWindowDocument, MaintenanceWindowModel>("MaintenanceWindow", MaintenanceWindowSchema);
 * ```
 */
export type MaintenanceWindowModel = mongoose.Model<
  MaintenanceWindowDocument,
  MaintenanceWindowQueries
> &
  MaintenanceWindowStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new MaintenanceWindow schema instances:
 * ```
 * const MaintenanceWindowSchema: MaintenanceWindowSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MaintenanceWindowSchema = mongoose.Schema<
  MaintenanceWindowDocument,
  MaintenanceWindowModel,
  MaintenanceWindowMethods,
  MaintenanceWindowQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MaintenanceWindow = mongoose.model<MaintenanceWindowDocument, MaintenanceWindowModel>("MaintenanceWindow", MaintenanceWindowSchema);
 * ```
 */
export type MaintenanceWindowDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MaintenanceWindowQueries
> &
  MaintenanceWindowMethods & {
    name: string;
    daysBefore: number;
    daysAfter: number;
    recurrency:
      | "daily"
      | "weekly"
      | "monthly"
      | "quarterly"
      | "semi-anually"
      | "annually";
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ProductComissioningDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProductComissioningDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProductComissioningObject`.
 * ```
 * const productcomissioningObject = productcomissioning.toObject();
 * ```
 */
export type ProductComissioning = {
  outcome: "fail" | "pass";
  details?: string;
  attachments: mongoose.Types.ObjectId[];
  productId: Product;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ProductComissioningDocument (type alias of `ProductComissioning`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ProductComissioning } from "../models"
 * import { ProductComissioningObject } from "../interfaces/mongoose.gen.ts"
 *
 * const productcomissioningObject: ProductComissioningObject = productcomissioning.toObject();
 * ```
 */
export type ProductComissioningObject = ProductComissioning;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProductComissioningQuery = mongoose.Query<
  any,
  ProductComissioningDocument,
  ProductComissioningQueries
> &
  ProductComissioningQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ProductComissioningSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProductComissioningQueries = {
  paginate: (
    this: ProductComissioningQuery,
    ...args: any[]
  ) => ProductComissioningQuery;
};

export type ProductComissioningMethods = {};

export type ProductComissioningStatics = {
  paginate: (this: ProductComissioningModel, ...args: any[]) => any;
  paginateSubDocs: (this: ProductComissioningModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductComissioning = mongoose.model<ProductComissioningDocument, ProductComissioningModel>("ProductComissioning", ProductComissioningSchema);
 * ```
 */
export type ProductComissioningModel = mongoose.Model<
  ProductComissioningDocument,
  ProductComissioningQueries
> &
  ProductComissioningStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new ProductComissioning schema instances:
 * ```
 * const ProductComissioningSchema: ProductComissioningSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProductComissioningSchema = mongoose.Schema<
  ProductComissioningDocument,
  ProductComissioningModel,
  ProductComissioningMethods,
  ProductComissioningQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductComissioning = mongoose.model<ProductComissioningDocument, ProductComissioningModel>("ProductComissioning", ProductComissioningSchema);
 * ```
 */
export type ProductComissioningDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ProductComissioningQueries
> &
  ProductComissioningMethods & {
    outcome: "fail" | "pass";
    details?: string;
    attachments: mongoose.Types.Array<mongoose.Types.ObjectId>;
    productId: ProductDocument;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ProductMaintenanceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProductMaintenanceDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProductMaintenanceObject`.
 * ```
 * const productmaintenanceObject = productmaintenance.toObject();
 * ```
 */
export type ProductMaintenance = {
  name: string;
  description?: string;
  attachments: mongoose.Types.ObjectId[];
  productId: Product;
  date?: Date;
  type: "service" | "preventive-maintenance";
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ProductMaintenanceDocument (type alias of `ProductMaintenance`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ProductMaintenance } from "../models"
 * import { ProductMaintenanceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const productmaintenanceObject: ProductMaintenanceObject = productmaintenance.toObject();
 * ```
 */
export type ProductMaintenanceObject = ProductMaintenance;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProductMaintenanceQuery = mongoose.Query<
  any,
  ProductMaintenanceDocument,
  ProductMaintenanceQueries
> &
  ProductMaintenanceQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ProductMaintenanceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProductMaintenanceQueries = {
  paginate: (
    this: ProductMaintenanceQuery,
    ...args: any[]
  ) => ProductMaintenanceQuery;
};

export type ProductMaintenanceMethods = {};

export type ProductMaintenanceStatics = {
  paginate: (this: ProductMaintenanceModel, ...args: any[]) => any;
  paginateSubDocs: (this: ProductMaintenanceModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductMaintenance = mongoose.model<ProductMaintenanceDocument, ProductMaintenanceModel>("ProductMaintenance", ProductMaintenanceSchema);
 * ```
 */
export type ProductMaintenanceModel = mongoose.Model<
  ProductMaintenanceDocument,
  ProductMaintenanceQueries
> &
  ProductMaintenanceStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new ProductMaintenance schema instances:
 * ```
 * const ProductMaintenanceSchema: ProductMaintenanceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProductMaintenanceSchema = mongoose.Schema<
  ProductMaintenanceDocument,
  ProductMaintenanceModel,
  ProductMaintenanceMethods,
  ProductMaintenanceQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductMaintenance = mongoose.model<ProductMaintenanceDocument, ProductMaintenanceModel>("ProductMaintenance", ProductMaintenanceSchema);
 * ```
 */
export type ProductMaintenanceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ProductMaintenanceQueries
> &
  ProductMaintenanceMethods & {
    name: string;
    description?: string;
    attachments: mongoose.Types.Array<mongoose.Types.ObjectId>;
    productId: ProductDocument;
    date?: Date;
    type: "service" | "preventive-maintenance";
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ProductTypeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProductTypeDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProductTypeObject`.
 * ```
 * const producttypeObject = producttype.toObject();
 * ```
 */
export type ProductType = {
  name: string;
  description?: string;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ProductTypeDocument (type alias of `ProductType`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ProductType } from "../models"
 * import { ProductTypeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const producttypeObject: ProductTypeObject = producttype.toObject();
 * ```
 */
export type ProductTypeObject = ProductType;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProductTypeQuery = mongoose.Query<
  any,
  ProductTypeDocument,
  ProductTypeQueries
> &
  ProductTypeQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ProductTypeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProductTypeQueries = {
  paginate: (this: ProductTypeQuery, ...args: any[]) => ProductTypeQuery;
};

export type ProductTypeMethods = {};

export type ProductTypeStatics = {
  paginate: (this: ProductTypeModel, ...args: any[]) => any;
  paginateSubDocs: (this: ProductTypeModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductType = mongoose.model<ProductTypeDocument, ProductTypeModel>("ProductType", ProductTypeSchema);
 * ```
 */
export type ProductTypeModel = mongoose.Model<
  ProductTypeDocument,
  ProductTypeQueries
> &
  ProductTypeStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new ProductType schema instances:
 * ```
 * const ProductTypeSchema: ProductTypeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProductTypeSchema = mongoose.Schema<
  ProductTypeDocument,
  ProductTypeModel,
  ProductTypeMethods,
  ProductTypeQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ProductType = mongoose.model<ProductTypeDocument, ProductTypeModel>("ProductType", ProductTypeSchema);
 * ```
 */
export type ProductTypeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ProductTypeQueries
> &
  ProductTypeMethods & {
    name: string;
    description?: string;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of ProductDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProductDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProductObject`.
 * ```
 * const productObject = product.toObject();
 * ```
 */
export type Product = {
  productTypeIds: ProductType[];
  vendorIds: Contact[];
  makeIds: Contact[];
  productModel: string;
  serialNumber: string;
  acquiredDate: Date;
  acquiredPrice: number;
  currentPrice: number;
  condition: "excellent" | "good" | "fair" | "poor";
  maintenanceWindowIds: MaintenanceWindow[];
  photo?: mongoose.Types.ObjectId;
  locationId: Room;
  warrantyDate: Date;
  remarks?: string;
  status?:
    | "active"
    | "awaiting-comissioning"
    | "under-service"
    | "decomissioned"
    | "in-pm";
  minMaintenanceDate?: Date;
  maintenanceDate?: Date;
  maxMaintenanceDate?: Date;
  active?: boolean;
  _id: mongoose.Types.ObjectId;
  productComission: any;
  productMaintenances: any;
};

/**
 * Lean version of ProductDocument (type alias of `Product`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Product } from "../models"
 * import { ProductObject } from "../interfaces/mongoose.gen.ts"
 *
 * const productObject: ProductObject = product.toObject();
 * ```
 */
export type ProductObject = Product;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProductQuery = mongoose.Query<
  any,
  ProductDocument,
  ProductQueries
> &
  ProductQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ProductSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProductQueries = {
  paginate: (this: ProductQuery, ...args: any[]) => ProductQuery;
};

export type ProductMethods = {};

export type ProductStatics = {
  paginate: (this: ProductModel, ...args: any[]) => any;
  paginateSubDocs: (this: ProductModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Product = mongoose.model<ProductDocument, ProductModel>("Product", ProductSchema);
 * ```
 */
export type ProductModel = mongoose.Model<ProductDocument, ProductQueries> &
  ProductStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Product schema instances:
 * ```
 * const ProductSchema: ProductSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProductSchema = mongoose.Schema<
  ProductDocument,
  ProductModel,
  ProductMethods,
  ProductQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Product = mongoose.model<ProductDocument, ProductModel>("Product", ProductSchema);
 * ```
 */
export type ProductDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ProductQueries
> &
  ProductMethods & {
    productTypeIds: mongoose.Types.Array<ProductTypeDocument>;
    vendorIds: mongoose.Types.Array<ContactDocument>;
    makeIds: mongoose.Types.Array<ContactDocument>;
    productModel: string;
    serialNumber: string;
    acquiredDate: Date;
    acquiredPrice: number;
    currentPrice: number;
    condition: "excellent" | "good" | "fair" | "poor";
    maintenanceWindowIds: mongoose.Types.Array<MaintenanceWindowDocument>;
    photo?: mongoose.Types.ObjectId;
    locationId: RoomDocument;
    warrantyDate: Date;
    remarks?: string;
    status?:
      | "active"
      | "awaiting-comissioning"
      | "under-service"
      | "decomissioned"
      | "in-pm";
    minMaintenanceDate?: Date;
    maintenanceDate?: Date;
    maxMaintenanceDate?: Date;
    active?: boolean;
    _id: mongoose.Types.ObjectId;
    productComission: any;
    productMaintenances: any;
  };

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
    }
  : DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module "mongoose" {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;
  }
}
